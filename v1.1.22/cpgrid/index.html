<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parsing and processing of corner-point grids · GeoEnergyIO.jl</title><meta name="title" content="Parsing and processing of corner-point grids · GeoEnergyIO.jl"/><meta property="og:title" content="Parsing and processing of corner-point grids · GeoEnergyIO.jl"/><meta property="twitter:title" content="Parsing and processing of corner-point grids · GeoEnergyIO.jl"/><meta name="description" content="Documentation for GeoEnergyIO.jl."/><meta property="og:description" content="Documentation for GeoEnergyIO.jl."/><meta property="twitter:description" content="Documentation for GeoEnergyIO.jl."/><meta property="og:url" content="https://sintefmath.github.io/GeoEnergyIO.jl/cpgrid/"/><meta property="twitter:url" content="https://sintefmath.github.io/GeoEnergyIO.jl/cpgrid/"/><link rel="canonical" href="https://sintefmath.github.io/GeoEnergyIO.jl/cpgrid/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GeoEnergyIO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../parser/">Parsing of simulation cases</a></li><li class="is-active"><a class="tocitem" href>Parsing and processing of corner-point grids</a><ul class="internal"><li><a class="tocitem" href="#Example-corner-point-meshes"><span>Example corner point meshes</span></a></li><li><a class="tocitem" href="#Generation-of-corner-point-meshes"><span>Generation of corner-point meshes</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../resdata/">resdata extension: Dealing with summary, restart and egrid files</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Parsing and processing of corner-point grids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parsing and processing of corner-point grids</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sintefmath/GeoEnergyIO.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sintefmath/GeoEnergyIO.jl/blob/main/docs/src/cpgrid.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parsing-and-processing-of-corner-point-grids"><a class="docs-heading-anchor" href="#Parsing-and-processing-of-corner-point-grids">Parsing and processing of corner-point grids</a><a id="Parsing-and-processing-of-corner-point-grids-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing-and-processing-of-corner-point-grids" title="Permalink"></a></h1><p>Corner-point meshes are the de-facto standard format for simulation of subsurface flow. These meshes are semi-structured, but can have quite complex structure in practice due to eroded and collapsed cells and the presence of faults. This module includes a processor to convert the input format into a mesh that can be used for simulation. Converting the corner-points into a mesh with a connected topology is non-trivial, but the included algorithm has been verified on a number of real-field assets.</p><p>There are two main functions to parse and process corner-point inputs:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeoEnergyIO.InputParser.parse_grdecl_file" href="#GeoEnergyIO.InputParser.parse_grdecl_file"><code>GeoEnergyIO.InputParser.parse_grdecl_file</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parse_grdecl_file(&quot;mygrid.grdecl&quot;; actnum_path = missing, kwarg...)</code></pre><p>Parse a GRDECL file separately from the full input file. Note that the GRID section does not contain units - passing the <code>input_units</code> keyword is therefore highly recommended.</p><p><strong>Keyword arguments</strong></p><ul><li><code>actnum_path=missing</code>: Path to ACTNUM file, if this is not included in the main file.</li><li><code>units=:si</code>: Units to use for return values. Requires <code>input_units</code> to be set.</li><li><code>input_units=nothing</code>: The units the file is given in.</li><li><code>verbose=false</code>: Toggle verbosity.</li><li><code>extra_paths</code>: List of extra paths to parse as a part of grid section, ex: <code>[&quot;PORO.inc&quot;, &quot;PERM.inc&quot;]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/GeoEnergyIO.jl/blob/fa4e875c4515ed305d82d4998c3b684d61e19a8e/src/InputParser/parser.jl#L274-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeoEnergyIO.CornerPointGrid.mesh_from_grid_section" href="#GeoEnergyIO.CornerPointGrid.mesh_from_grid_section"><code>GeoEnergyIO.CornerPointGrid.mesh_from_grid_section</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mesh_from_grid_section(f, actnum = missing, repair_zcorn = true, process_pinch = false)</code></pre><p>Generate a Jutul unstructured mesh from a grid section. The input arugment <code>f</code> can be one of the following:</p><ul><li>(1) An already parsed complete data file read using <code>parse_data_file</code>. The &quot;GRID&quot; field will be used.</li><li>(2) A parsed &quot;GRID&quot; section from <code>parse_grdecl_file</code>.</li><li>(3) The file-name of a <code>.GRDECL</code> file to be parsed before processing.</li></ul><p>Optionally the <code>actnum</code> can be specified separately. The <code>actnum</code> should have equal length to the number of logical cells in the grid with true/false indicating if a cell is to be included in the processed mesh.</p><p>The additional argument <code>repair_zcorn</code> only applies when the grid is defined using COORD/ZCORN arrays. If set to <code>true</code>, the monotonicity of the ZCORN coordinates in each corner-point pillar will be checked and optionally fixed prior to mesh construction. Note that if non-monotone ZCORN are fixed, if the first input argument to this function is an already parsed data structure, the ZCORN array will be mutated during fixing to avoid a copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/GeoEnergyIO.jl/blob/fa4e875c4515ed305d82d4998c3b684d61e19a8e/src/CornerPointGrid/interface.jl#L1-L22">source</a></section></article><h2 id="Example-corner-point-meshes"><a class="docs-heading-anchor" href="#Example-corner-point-meshes">Example corner point meshes</a><a id="Example-corner-point-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Example-corner-point-meshes" title="Permalink"></a></h2><p>The module ships with several corner point grids suitable for testing. These include partially collapsed cells, faults and other degenerate cases that the parser should be able to handle. We can make a few plots of such test grids. The first example is a single hexahedral cell:</p><pre><code class="language-julia hljs">using GeoEnergyIO, Jutul, GLMakie
pth = GeoEnergyIO.test_input_file_path(&quot;grdecl&quot;, &quot;1cell.txt&quot;)
grdecl = parse_grdecl_file(pth)
g = mesh_from_grid_section(grdecl)
fig, ax, plt = plot_mesh(g)
Jutul.plot_mesh_edges!(ax, g)
fig</code></pre><img src="7ac330b1.png" alt="Example block output"/><p>To understand a bit more of how this format behaves in practice, we can look at a faulted mesh:</p><pre><code class="language-julia hljs">using GeoEnergyIO, Jutul, GLMakie
pth = GeoEnergyIO.test_input_file_path(&quot;grdecl&quot;, &quot;raised_col_sloped.txt&quot;)
grdecl = parse_grdecl_file(pth)
g = mesh_from_grid_section(grdecl)
fig, ax, plt = plot_mesh(g)
Jutul.plot_mesh_edges!(ax, g)
fig</code></pre><img src="1b82f27b.png" alt="Example block output"/><p>More complicated meshes include multiple faults. One synthetic test model is the <code>model3</code> case from <a href="https://www.mrst.no">MRST</a>:</p><pre><code class="language-julia hljs">using GeoEnergyIO, Jutul, GLMakie
pth = GeoEnergyIO.test_input_file_path(&quot;grdecl&quot;, &quot;model3_5_5_5.txt&quot;)
grdecl = parse_grdecl_file(pth)
g = mesh_from_grid_section(grdecl)
ix = collect(1:number_of_cells(g))
fig = Figure()
ax = Axis3(fig[1,1], zreversed = true, azimuth = 2.0)
plot_cell_data!(ax, g, ix, colormap = :seaborn_icefire_gradient)
fig</code></pre><img src="195c924b.png" alt="Example block output"/><p>We can also parse a high-resolution version of the same case:</p><pre><code class="language-julia hljs">using GeoEnergyIO, Jutul, GLMakie
pth = GeoEnergyIO.test_input_file_path(&quot;grdecl&quot;, &quot;model3_20_20_50.txt&quot;)
grdecl = parse_grdecl_file(pth)
g = mesh_from_grid_section(grdecl)
ix = collect(1:number_of_cells(g))
fig = Figure()
ax = Axis3(fig[1,1], zreversed = true, azimuth = 2.0)
plot_cell_data!(ax, g, ix, colormap = :seaborn_icefire_gradient)
fig</code></pre><img src="6a4742b7.png" alt="Example block output"/><p>The parser has been tested on many complex models. Here is an example mesh parsed from the <a href="https://doi.org/10.1007/s10596-020-10003-4">OLYMPUS Optimization Benchmark Challenge</a> where the parsed porosity is plotted together with the wells:</p><p><img src="../assets/olympus_small.gif" alt="image"/></p><p>We can parse this mesh in the same manner as before:</p><pre><code class="language-julia hljs">using GeoEnergyIO, Jutul, GLMakie
pth = GeoEnergyIO.test_input_file_path(&quot;OLYMPUS_1&quot;, &quot;OLYMPUS_GRID.GRDECL&quot;)
grdecl = parse_grdecl_file(pth)
g = mesh_from_grid_section(grdecl)
ix = collect(1:number_of_cells(g))
fig = Figure()
ax = Axis3(fig[1,1], zreversed = true, azimuth = 2.0)
plot_cell_data!(ax, g, ix, colormap = :seaborn_icefire_gradient)
fig</code></pre><img src="9defd8a9.png" alt="Example block output"/><h2 id="Generation-of-corner-point-meshes"><a class="docs-heading-anchor" href="#Generation-of-corner-point-meshes">Generation of corner-point meshes</a><a id="Generation-of-corner-point-meshes-1"></a><a class="docs-heading-anchor-permalink" href="#Generation-of-corner-point-meshes" title="Permalink"></a></h2><p>The package also contains functionality for generating corner-point meshes.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeoEnergyIO.CornerPointGrid.cpgrid_from_horizons" href="#GeoEnergyIO.CornerPointGrid.cpgrid_from_horizons"><code>GeoEnergyIO.CornerPointGrid.cpgrid_from_horizons</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cpgrid_from_horizons(X, Y, depths)
cpgrid_from_horizons(X, Y, depths, (100, 100))
cpgrid_from_horizons(X, Y, depths, sz = missing;
    layer_width = 1,
    transforms = [(x, y, z, x_c, y_c, i, j, k) -&gt; z],
    xy_transform = (x, y, i, j, z_t, z_b) -&gt; (x, y, x, y)
)</code></pre><p>Create a CornerPointGrid from a set of horizons. The horizons are given as a set of 2D arrays, where each array represents the depth of a horizon at each point in the grid. The horizons must be the same size and will be used to create the top and bottom of each cell in the grid. At least two horizons must be provided, one for the top and one for the bottom of the grid, and additional horizons can be provided. If horizons intersect, the cells will be pinched so that the lowest horizon is preserved.</p><p>The grid will be created with the given <code>X</code> and <code>Y</code> coordinates which are vectors/ranges of equal length to the number of rows and columns in the depths arrays. The <code>sz</code> argument can be used to resample the grid to a different size in the I/J directions. If <code>sz</code> is not provided, the grid will have the same size as the horizons.</p><p><strong>Keyword arguments</strong></p><ul><li><code>layer_width</code>: Number of cells inside each layer. Can be a single integer or an array of integers with the same length as the number of horizons/depths minus one. Default is 1, i.e. that each layer has one cell in the vertical direction.</li><li><code>transforms</code>: A function or an array of functions that can be used to modify the depth of each cell. The function(s) should take the following arguments: <code>x</code>, <code>y</code>, <code>z</code>, <code>x_c</code>, <code>y_c</code>, <code>i</code>, <code>j</code>, <code>k</code>, where <code>x</code>, <code>y</code> and <code>z</code> are the coordinates of the point to be modified, <code>x_c</code> and <code>y_c</code> are the coordinates of the cell center that the point belongs to, <code>i</code> and <code>j</code> are the indices of the cell in the I/J directions, and <code>k</code> is the index of the cell in the K direction. The function(s) should return the new depth of the point.</li><li><code>xy_transform</code>: A function that can be used to modify the X and Y coordinates of each pillar. The function should take the following arguments: <code>x</code>, <code>y</code>, <code>i</code>, <code>j</code>, <code>z_t</code>, <code>z_b</code>, where <code>x</code> and <code>y</code> are the original X and Y coordinates of the line, <code>i</code> and <code>j</code> are the indices of the line in the I/J directions, and <code>z_t</code> and <code>z_b</code> are the top and bottom depths of the line. The function should return the new X and Y coordinates of the line.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/GeoEnergyIO.jl/blob/fa4e875c4515ed305d82d4998c3b684d61e19a8e/src/CornerPointGrid/generation.jl#L1-L43">source</a></section></article><h3 id="Example-of-mesh-generation"><a class="docs-heading-anchor" href="#Example-of-mesh-generation">Example of mesh generation</a><a id="Example-of-mesh-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-mesh-generation" title="Permalink"></a></h3><p>Let us look at how the corner-point generator can be used in practice. A common concept of horizons, a more or less continious surface where the litography changes significantly. Typically these horizons would come from data, but for the purpose of this example we will generate some noisy surfaces with different averages and trends. One matrix for the top surface, one for the middle and one for the bottom of our domain.</p><pre><code class="language-julia hljs">using GeoEnergyIO, Jutul, GLMakie
nx = ny = 25
Lx = 1000.0
Ly = 800.0
xrng = range(0.0, Lx, nx)
yrng = range(0.0, Ly, ny)
depths = [
    5 .*rand(nx, ny),
    5 .*rand(nx, ny) .+ 30.0,
    5 .*rand(nx, ny) .+ 100.0 .- xrng/Lx*40.0
]
fig = Figure()
ax = Axis3(fig[1, 1], zreversed = true)
colors = Makie.wong_colors()
for (c, layer) in enumerate(depths)
    surface!(ax, xrng, yrng, layer, color = fill(colors[c], nx, ny), shading = NoShading)
end
fig</code></pre><img src="7987d2fb.png" alt="Example block output"/><p>We generate a mesh based on these depth matrices for each horizon, creating two layers with three cells each, and turn the keyword <code>Dict</code> into a mesh:</p><pre><code class="language-julia hljs">grd = cpgrid_from_horizons(xrng, yrng, depths, layer_width = 3)
mesh = mesh_from_grid_section(grd)
fig, ax, plt = plot_cell_data(mesh, grd[&quot;LAYERNUM&quot;][mesh.cell_map], colormap = :winter)
Jutul.plot_mesh_edges!(ax, mesh)
fig</code></pre><img src="154e4192.png" alt="Example block output"/><p>Let us say that the data was at a different resolution than what we want for our simulation mesh. We can increase or decrease the resolution by a third keyword argument, which will use linear interpolation to add additional points:</p><pre><code class="language-julia hljs">grd = cpgrid_from_horizons(xrng, yrng, depths, (100, 100), layer_width = [20, 25])
mesh2 = mesh_from_grid_section(grd)
fig, ax, plt = plot_cell_data(mesh2, grd[&quot;LAYERNUM&quot;][mesh2.cell_map], colormap = :winter)
Jutul.plot_mesh_edges!(ax, mesh2)
fig</code></pre><img src="fa30eaac.png" alt="Example block output"/><p>We can also add various transforms to make the model complex. There are two types of supported transforms:</p><ol><li>Vertical transforms, which can be multiple transforms that change the depths of corner points based on the cell centroid and original corner points. These are typically used to create faults.</li><li>Pillar transforms, which can alter the top and bottom points of the pillars that define the corner point mesh. A single transform is supported at the time.</li></ol><p>We will now do the following:</p><ol><li>Introduce two faults, one sloping and one with fixed throw.</li><li>Add a pillar transform that makes the mesh smaller for increasing depth.</li></ol><pre><code class="language-julia hljs">fault1 = (x, y, z, x_c, y_c, i, j, k) -&gt; ifelse(x_c/Lx + 0.25*y_c/Ly &gt; 0.5, z + 50.0.*(y/Ly) + 15.0, z)
fault2 = (x, y, z, x_c, y_c, i, j, k) -&gt; ifelse(y_c/Ly &gt; 0.5, z + 25.0, z)
transforms = [fault1, fault2]
xy_transform = (x, y, i, j, zt, zb) -&gt; (x, y, 0.9*x, 0.8*y)
grd = cpgrid_from_horizons(xrng, yrng, depths,
    layer_width = 3,
    transforms = transforms,
    xy_transform = xy_transform
)
mesh3 = mesh_from_grid_section(grd)
fig, ax, plt = plot_cell_data(mesh3, grd[&quot;LAYERNUM&quot;][mesh3.cell_map], colormap = :winter)
ax.azimuth[] = 5.44
Jutul.plot_mesh_edges!(ax, mesh3)
fig</code></pre><img src="509dd209.png" alt="Example block output"/><p>We can also make cells inactive by setting <code>NaN</code> values in the depths. Note that as each entry in <code>depths</code> corresponds to the intersection between two layers, we set <code>NaN</code> in the top and bottom depths to impact the two layers separately. For more fine grained control, the <code>&quot;ACTNUM&quot;</code> array is also present and can be altered before <code>mesh_from_grid_section</code> is called.</p><pre><code class="language-julia hljs">for i in 1:nx
    for j in 1:ny
        center_dist = sqrt((xrng[i] - 500)^2 + (yrng[j] - 400)^2)
        if center_dist &gt; 400
            depths[1][i, j] = NaN
        end
        if center_dist &gt; 500
            depths[3][i, j] = NaN
        end
    end
end
grd = cpgrid_from_horizons(xrng, yrng, depths, layer_width = [20, 25])
mesh4 = mesh_from_grid_section(grd)
fig, ax, plt = plot_cell_data(mesh4, grd[&quot;LAYERNUM&quot;][mesh4.cell_map], colormap = :winter)
Jutul.plot_mesh_edges!(ax, mesh4)
fig</code></pre><img src="5bae6e9c.png" alt="Example block output"/><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeoEnergyIO.InputParser.get_data_file_cell_region" href="#GeoEnergyIO.InputParser.get_data_file_cell_region"><code>GeoEnergyIO.InputParser.get_data_file_cell_region</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">region = get_data_file_cell_region(data, t::Symbol; active = nothing)
satnum = get_data_file_cell_region(data, :satnum)
pvtnum = get_data_file_cell_region(data, :pvtnum, active = 1:10)</code></pre><p>Get the region indicator of some type for each cell of the domain stored in <code>data</code> (the output from <a href="../parser/#GeoEnergyIO.InputParser.parse_data_file"><code>parse_data_file</code></a>). The optional keyword argument <code>active</code> can be used to extract the values for a subset of cells.</p><p><code>t</code> should be one of the following:</p><ul><li><code>:satnum</code> (saturation function region)</li><li><code>:pvtnum</code> (PVT function region)</li><li><code>:eqlnum</code> (equilibriation region)</li><li><code>:eosnum</code> (equation-of-state region)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/GeoEnergyIO.jl/blob/fa4e875c4515ed305d82d4998c3b684d61e19a8e/src/InputParser/utils.jl#L542-L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeoEnergyIO.InputParser.number_of_tables" href="#GeoEnergyIO.InputParser.number_of_tables"><code>GeoEnergyIO.InputParser.number_of_tables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">number_of_tables(outer_data, t::Symbol)</code></pre><p>Number of declared tables for given type <code>t</code>. Should be one of the following:</p><ul><li><code>:satnum</code> (saturation function region)</li><li><code>:pvtnum</code> (PVT function region)</li><li><code>:eqlnum</code> (equilibriation region)</li><li><code>:eosnum</code> (equation-of-state region)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sintefmath/GeoEnergyIO.jl/blob/fa4e875c4515ed305d82d4998c3b684d61e19a8e/src/InputParser/utils.jl#L477-L485">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../parser/">« Parsing of simulation cases</a><a class="docs-footer-nextpage" href="../resdata/">resdata extension: Dealing with summary, restart and egrid files »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 5 March 2025 08:45">Wednesday 5 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
