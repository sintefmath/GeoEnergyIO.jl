var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeoEnergyIO","category":"page"},{"location":"#GeoEnergyIO","page":"Home","title":"GeoEnergyIO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GeoEnergyIO.","category":"page"},{"location":"#Parsing-of-simulation-cases","page":"Home","title":"Parsing of simulation cases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main feature of this module is at the time of writing a parser for .DATA reservoir simulation cases. The format originated with the Eclipse reservoir simulator produced by SLB and is now used by many reservoir simulators. The most useful publicly available description of one such dialect is found in the OPM Flow manual.","category":"page"},{"location":"","page":"Home","title":"Home","text":"parse_data_file","category":"page"},{"location":"#GeoEnergyIO.InputParser.parse_data_file","page":"Home","title":"GeoEnergyIO.InputParser.parse_data_file","text":"parse_data_file(filename; units = :si)\nparse_data_file(filename; units = :field)\ndata = parse_data_file(\"MY_MODEL.DATA\")\n\nParse a .DATA file given by the path in filename (industry standard input file) into a Dict with String keys. Units will be converted to strict SI unless you pass an alternative unit system like units = :field. Setting units = nothing will skip unit conversion. Note that the simulators in JutulDarcy.jl assumes that the unit system is internally consistent. It is highly recommended to parse to the SI units if you want to perform simulations with JutulDarcy.jl.\n\nThe best publicly available documentation on this format is available from the Open Porous Media (OPM) project's webpages: OPM Flow manual .\n\nKeyword arguments\n\nwarn_parsing=true: Produce a warning when keywords are not supported (or partially supported) by the parser.\nwarn_feature=true: Produce a warning when keywords are supported, but have limited or missing support in the numerical solvers in JutulDarcy.jl.\nunits=:si: Symbol that indicates the unit system to be used in the output. Setting this to nothing will return values without conversion, i.e. exactly what is in the input files. :si will use strict SI. Other alternatives are :field and :metric. :lab is currently unsupported.\nverbose=false: Produce verbose output about parsing progress. For larger files, a lot of output will be generated. Useful when figuring out where a parser fails or spends a lot of time.\n\nNote\n\nThis function only covers a small portion of the keywords that exist for various simulators. You will get warnings that indicate the level of support for keywords in both the parser and the numerical solvers when known keywords with limited support. Pull requests for new keywords are welcome!\n\nThe SUMMARY section is skipped due to the large volume of available keywords that are not essential to define simulation cases.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Let us for example parse the SPE1 dataset, turning into a nested Dict containing all the entries of the data file. We use the unexported test_input_file_path utility to get the path of a test file.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeoEnergyIO\nspe1_pth = GeoEnergyIO.test_input_file_path(\"SPE1\", \"SPE1.DATA\")\nspe1 = parse_data_file(spe1_pth)","category":"page"},{"location":"#Handling-unsupported-keywords","page":"Home","title":"Handling unsupported keywords","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Not all keywords are supported by the parser, but not all keywords are important. The input format is such that it is difficult to automatically skip keywords, but you an manually add keywords to the skip list:","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeoEnergyIO.InputParser.skip_kw!","category":"page"},{"location":"#GeoEnergyIO.InputParser.skip_kw!","page":"Home","title":"GeoEnergyIO.InputParser.skip_kw!","text":"skip_kw!(kw, num, msg = nothing)\n\nAdd a keyword to list of records that will be skipped on parsing.\n\nkw is the symbol (usually capitalized) of the keyword to skip, num is the number of expected records:\n\n0 means that the keyword to skip has no data (for example \"WATER\" with no data to follow)\n1 means that the keyword has a single record terminated by /\nAny other number means a fixed number of lines, without termination by empty record.\nInf means that the keyword has any number of records, terminated by a record without entries.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Adding keywords to the skip list is not persistent across Julia sessions and can be added to the top of your script. Contributions to the global skip list defined in the __init__ function of the parser are welcome.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeoEnergyIO\n# Skip keyword without data\nGeoEnergyIO.InputParser.skip_kw!(:MY_KW, 0)\n# Keyword with a single record of data, e.g.\n# MY_DATA_KW\n# \"some data\" 1 2 3 /\nGeoEnergyIO.InputParser.skip_kw!(:MY_DATA_KW, 1)\n# Keyword with many records, terminated by empty record:\n# MY_LONG_DATA_KW\n# \"some data\" 1 2 3 /\n# \"more data\" 4 5 6 /\n# \"even more data\" 1 9 /\n# /\nGeoEnergyIO.InputParser.skip_kw!(:MY_LONG_DATA_KW, Inf)","category":"page"},{"location":"#Parsing-and-processing-of-corner-point-grids","page":"Home","title":"Parsing and processing of corner-point grids","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Corner-point meshes are the de-facto standard format for simulation of subsurface flow. These meshes are semi-structured, but can have quite complex structure in practice due to eroded and collapsed cells and the presence of faults. This module includes a processor to convert the input format into a mesh that can be used for simulation. Converting the corner-points into a mesh with a connected topology is non-trivial, but the included algorithm has been verified on a number of real-field assets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two main functions to parse and process corner-point inputs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parse_grdecl_file\nmesh_from_grid_section","category":"page"},{"location":"#GeoEnergyIO.InputParser.parse_grdecl_file","page":"Home","title":"GeoEnergyIO.InputParser.parse_grdecl_file","text":"parse_grdecl_file(\"mygrid.grdecl\"; actnum_path = missing, kwarg...)\n\nParse a GRDECL file separately from the full input file. Note that the GRID section does not contain units - passing the input_units keyword is therefore highly recommended.\n\nKeyword arguments\n\nactnum_path=missing: Path to ACTNUM file, if this is not included in the main file.\nunits=:si: Units to use for return values. Requires input_units to be set.\ninput_units=nothing: The units the file is given in.\nverbose=false: Toggle verbosity.\nextra_paths: List of extra paths to parse as a part of grid section, ex: [\"PORO.inc\", \"PERM.inc\"].\n\n\n\n\n\n","category":"function"},{"location":"#GeoEnergyIO.CornerPointGrid.mesh_from_grid_section","page":"Home","title":"GeoEnergyIO.CornerPointGrid.mesh_from_grid_section","text":"mesh_from_grid_section(f, actnum = missing, repair_zcorn = true, process_pinch = false)\n\nGenerate a Jutul unstructured mesh from a grid section. The input arugment f can be one of the following:\n\n(1) An already parsed complete data file read using parse_data_file. The \"GRID\" field will be used.\n(2) A parsed \"GRID\" section from parse_grdecl_file.\n(3) The file-name of a .GRDECL file to be parsed before processing.\n\nOptionally the actnum can be specified separately. The actnum should have equal length to the number of logical cells in the grid with true/false indicating if a cell is to be included in the processed mesh.\n\nThe additional argument repair_zcorn only applies when the grid is defined using COORD/ZCORN arrays. If set to true, the monotonicity of the ZCORN coordinates in each corner-point pillar will be checked and optionally fixed prior to mesh construction. Note that if non-monotone ZCORN are fixed, if the first input argument to this function is an already parsed data structure, the ZCORN array will be mutated during fixing to avoid a copy.\n\n\n\n\n\n","category":"function"},{"location":"#Example-corner-point-meshes","page":"Home","title":"Example corner point meshes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The module ships with several corner point grids suitable for testing. These include partially collapsed cells, faults and other degenerate cases that the parser should be able to handle. We can make a few plots of such test grids. The first example is a single hexahedral cell:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeoEnergyIO, Jutul, CairoMakie\npth = GeoEnergyIO.test_input_file_path(\"grdecl\", \"1cell.txt\")\ngrdecl = parse_grdecl_file(pth)\ng = mesh_from_grid_section(grdecl)\nfig, ax, plt = plot_mesh(g, shading = false, rasterize = true)\nJutul.plot_mesh_edges!(ax, g)\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"To understand a bit more of how this format behaves in practice, we can look at a faulted mesh:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeoEnergyIO, Jutul, CairoMakie\npth = GeoEnergyIO.test_input_file_path(\"grdecl\", \"raised_col_sloped.txt\")\ngrdecl = parse_grdecl_file(pth)\ng = mesh_from_grid_section(grdecl)\nfig, ax, plt = plot_mesh(g, shading = NoShading, rasterize = true)\nJutul.plot_mesh_edges!(ax, g)\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"More complicated meshes include multiple faults. One synthetic test model is the model3 case from MRST:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeoEnergyIO, Jutul, CairoMakie\npth = GeoEnergyIO.test_input_file_path(\"grdecl\", \"model3_5_5_5.txt\")\ngrdecl = parse_grdecl_file(pth)\ng = mesh_from_grid_section(grdecl)\nix = collect(1:number_of_cells(g))\nfig = Figure()\nax = Axis3(fig[1,1], zreversed = true, azimuth = 2.0)\nplot_cell_data!(ax, g, ix, shading = NoShading, rasterize = true, colormap = :seaborn_icefire_gradient)\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can also parse a high-resolution version of the same case:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeoEnergyIO, Jutul, CairoMakie\npth = GeoEnergyIO.test_input_file_path(\"grdecl\", \"model3_20_20_50.txt\")\ngrdecl = parse_grdecl_file(pth)\ng = mesh_from_grid_section(grdecl)\nix = collect(1:number_of_cells(g))\nfig = Figure()\nax = Axis3(fig[1,1], zreversed = true, azimuth = 2.0)\nplot_cell_data!(ax, g, ix, shading = NoShading, rasterize = true, colormap = :seaborn_icefire_gradient)\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"The parser has been tested on many complex models. Here is an example mesh parsed from the OLYMPUS Optimization Benchmark Challenge where the parsed porosity is plotted together with the wells:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can parse this mesh in the same manner as before:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GeoEnergyIO, Jutul, CairoMakie\npth = GeoEnergyIO.test_input_file_path(\"OLYMPUS_1\", \"OLYMPUS_GRID.GRDECL\")\ngrdecl = parse_grdecl_file(pth)\ng = mesh_from_grid_section(grdecl)\nix = collect(1:number_of_cells(g))\nfig = Figure()\nax = Axis3(fig[1,1], zreversed = true, azimuth = 2.0)\nplot_cell_data!(ax, g, ix, shading = NoShading, rasterize = true, colormap = :seaborn_icefire_gradient)\nfig","category":"page"},{"location":"#Utilities","page":"Home","title":"Utilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"get_data_file_cell_region\nnumber_of_tables","category":"page"},{"location":"#GeoEnergyIO.InputParser.get_data_file_cell_region","page":"Home","title":"GeoEnergyIO.InputParser.get_data_file_cell_region","text":"region = get_data_file_cell_region(data, t::Symbol; active = nothing)\nsatnum = get_data_file_cell_region(data, :satnum)\npvtnum = get_data_file_cell_region(data, :pvtnum, active = 1:10)\n\nGet the region indicator of some type for each cell of the domain stored in data (the output from parse_data_file). The optional keyword argument active can be used to extract the values for a subset of cells.\n\nt should be one of the following:\n\n:satnum (saturation function region)\n:pvtnum (PVT function region)\n:eqlnum (equilibriation region)\n:eosnum (equation-of-state region)\n\n\n\n\n\n","category":"function"},{"location":"#GeoEnergyIO.InputParser.number_of_tables","page":"Home","title":"GeoEnergyIO.InputParser.number_of_tables","text":"number_of_tables(outer_data, t::Symbol)\n\nNumber of declared tables for given type t. Should be one of the following:\n\n:satnum (saturation function region)\n:pvtnum (PVT function region)\n:eqlnum (equilibriation region)\n:eosnum (equation-of-state region)\n\n\n\n\n\n","category":"function"},{"location":"#Internals","page":"Home","title":"Internals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GeoEnergyIO.InputParser.keyword_default_value","category":"page"},{"location":"#GeoEnergyIO.InputParser.keyword_default_value","page":"Home","title":"GeoEnergyIO.InputParser.keyword_default_value","text":"keyword_default_value(x::AbstractString, T::Type)\n\nGet the default value of a keyword (as String or ::Val{X} where X is a Symbol) when placed in a array with element type T. This is used to initialize defaulted entries when using COPY, ADD, MULTIPLY and so on.\n\n\n\n\n\n","category":"function"},{"location":"#Index-of-functions","page":"Home","title":"Index of functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
